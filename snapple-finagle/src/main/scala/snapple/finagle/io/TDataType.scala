/**
 * Generated by Scrooge
 *   version: 4.6.0
 *   rev: eb57ae5452b3a7a1fe18ba3ebf6bcc0721393d8c
 *   built at: 20160418-101323
 */
package snapple.finagle.io

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUnion, TFieldBlob, ThriftUnionFieldInfo}
import org.apache.thrift.protocol._
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait TDataType extends ThriftUnion with ThriftStruct

private object TDataTypeDecoder {
  def apply(_iprot: TProtocol, newUnknown: TFieldBlob => TDataType): TDataType = {
    var _result: TDataType = null
    _iprot.readStructBegin()
    val _field = _iprot.readFieldBegin()
    _field.id match {
      case 1 => // orset
        _field.`type` match {
          case TType.STRUCT =>
            _result = TDataType.Orset({
              snapple.finagle.io.TORSet.decode(_iprot)
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 2 => // versionVector
        _field.`type` match {
          case TType.STRUCT =>
            _result = TDataType.VersionVector({
              snapple.finagle.io.TVersionVector.decode(_iprot)
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case _ =>
        if (_field.`type` != TType.STOP) {
          _result = newUnknown(TFieldBlob.read(_field, _iprot))
        } else {
          TProtocolUtil.skip(_iprot, _field.`type`)
        }
    }
    if (_field.`type` != TType.STOP) {
      _iprot.readFieldEnd()
      var _done = false
      var _moreThanOne = false
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP)
          _done = true
        else {
          _moreThanOne = true
          TProtocolUtil.skip(_iprot, _field.`type`)
          _iprot.readFieldEnd()
        }
      }
      if (_moreThanOne) {
        _iprot.readStructEnd()
        throw new TProtocolException("Cannot read a TUnion with more than one set value!")
      }
    }
    _iprot.readStructEnd()
    if (_result == null)
      throw new TProtocolException("Cannot read a TUnion with no set value!")
    _result
  }
}

object TDataTypeAliases {

  type OrsetAlias = snapple.finagle.io.TORSet

  def withoutPassthroughFields_Orset(obj: TDataType.Orset): TDataType.Orset = {
    val field = obj.orset
    TDataType.Orset(
      snapple.finagle.io.TORSet.withoutPassthroughFields(field)
    )
  }

  val OrsetKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val OrsetValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type VersionVectorAlias = snapple.finagle.io.TVersionVector

  def withoutPassthroughFields_VersionVector(obj: TDataType.VersionVector): TDataType.VersionVector = {
    val field = obj.versionVector
    TDataType.VersionVector(
      snapple.finagle.io.TVersionVector.withoutPassthroughFields(field)
    )
  }

  val VersionVectorKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val VersionVectorValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None
}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
object TDataType extends ThriftStructCodec3[TDataType] {
  val Union = new TStruct("TDataType")
  val OrsetField = new TField("orset", TType.STRUCT, 1)
  val OrsetFieldManifest = implicitly[Manifest[Orset]]
  val VersionVectorField = new TField("versionVector", TType.STRUCT, 2)
  val VersionVectorFieldManifest = implicitly[Manifest[VersionVector]]

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map.empty[String, String]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftUnionFieldInfo[_ <: TDataType, _]] = scala.List(
    new ThriftUnionFieldInfo[Orset, TDataTypeAliases.OrsetAlias](
      Orset.fieldInfo,
      Orset.unapply
    ),
    new ThriftUnionFieldInfo[VersionVector, TDataTypeAliases.VersionVectorAlias](
      VersionVector.fieldInfo,
      VersionVector.unapply
    )
  )

  override def encode(_item: TDataType, _oprot: TProtocol): Unit =
    _item.write(_oprot)

  override def decode(_iprot: TProtocol): TDataType =
    TDataTypeDecoder(_iprot, UnknownUnionField(_))

  def apply(_iprot: TProtocol): TDataType = decode(_iprot)

  import TDataTypeAliases._

  def withoutPassthroughFields(struct: TDataType): TDataType = {
    struct match {
      case obj: Orset => withoutPassthroughFields_Orset(obj)
      case obj: VersionVector => withoutPassthroughFields_VersionVector(obj)
      case unknown: UnknownUnionField => unknown // by definition pass-through
    }
  }

  object Orset extends (OrsetAlias => Orset) {
    def withoutPassthroughFields(obj: Orset): Orset =
      withoutPassthroughFields_Orset(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        OrsetField,
        false,
        false,
        manifest[OrsetAlias],
        OrsetKeyTypeManifest,
        OrsetValueTypeManifest,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
  }

  case class Orset(
      orset: OrsetAlias)
    extends TDataType {

    //protected type ContainedType = OrsetAlias

    def containedValue(): OrsetAlias = orset

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(Orset.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      if (orset == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (orset ne null) {
        val orset_item = orset
        _oprot.writeFieldBegin(OrsetField)
        orset_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object VersionVector extends (VersionVectorAlias => VersionVector) {
    def withoutPassthroughFields(obj: VersionVector): VersionVector =
      withoutPassthroughFields_VersionVector(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        VersionVectorField,
        false,
        false,
        manifest[VersionVectorAlias],
        VersionVectorKeyTypeManifest,
        VersionVectorValueTypeManifest,
        immutable$Map.empty[String, String],
        immutable$Map.empty[String, String]
      )
  }

  case class VersionVector(
      versionVector: VersionVectorAlias)
    extends TDataType {

    //protected type ContainedType = VersionVectorAlias

    def containedValue(): VersionVectorAlias = versionVector

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(VersionVector.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      if (versionVector == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (versionVector ne null) {
        val versionVector_item = versionVector
        _oprot.writeFieldBegin(VersionVectorField)
        versionVector_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  case class UnknownUnionField private[TDataType](
      private val field: TFieldBlob)
    extends TDataType {

    def containedValue(): Unit = ()

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] = _root_.scala.None

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      field.write(_oprot)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }
}